<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Multi-Petabyte Data Distribution in Industry & Science with CernVM File System</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white-fosdem-ish.css">
		<link rel="stylesheet" type="text/css" href="css/asciinema-player.css" />

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
					<textarea data-template>
					<img src="assets/img/fosdem-gear.svg">

					Multi-Petabyte Data Distribution in Industry & Science with CernVM File System

					<ul style="list-style-type: none;">
						<li>Georgios Christodoulis, CERN</li>
						<li>Andriy Utkin</li>
					</ul>

					<small>2026</small>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						# Fill in

						Contents go there
					</textarea>
				</section>

				<section data-markdown  data-background-image="./assets/img/bottle.png" data-background-opacity="1">
					<textarea data-template>
						<aside class="notes">
							5 seconds pause to let viewers appreciate the picture.

							Move on.
						</aside>
					</textarea>
				</section>

				<section data-markdown  data-background-image="./assets/img/bottle.png" data-background-opacity="0.1">
					<textarea data-template>
					## cvmfs-posix-tools

					<aside class="notes">
						These are new tools, modelled after popular file utilities, which offer the convenience of direct effect on CVMFS repo.
						With big uploads, performance will also be better.

						I believe availability of such commands will make CVMFS administration more attractive to potential adopters.
					</aside>

					<!-- Deemphasize common prefix, emphasize second half of command names -->
					<ul style="columns: 2; list-style-type: none;">
						<li>cvmfs_<strong>chgrp</strong></li>
						<li>cvmfs_<strong>chmod</strong></li>
						<li>cvmfs_<strong>chown</strong></li>
						<li>cvmfs_<strong>insert</strong></li>
						<li>cvmfs_<strong>ln</strong></li>
						<li>cvmfs_<strong>mkdir</strong></li>
						<li>cvmfs_<strong>rm</strong></li>
						<li>cvmfs_<strong>rmdir</strong></li>
						<li>cvmfs_<strong>rsync</strong></li>
						<li>cvmfs_<strong>setfacl</strong></li>
						<li>cvmfs_<strong>touch</strong></li>
					</ul>

					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						## Changing contents,<br>the usual way

						* `cvmfs_server transaction`
						* make changes
						* `cvmfs_server publish`

						<aside class="notes">
							To explain why they are needed, let's briefly see how changing contents <strong>currently</strong> works from the user perspective.

							The first method you learn from the documentation to change the contents of your repo is this:

							* `cvmfs_server transaction`
							* make changes
							* `cvmfs_server publish`

						</aside>
					</textarea>
				</section>

				<section>
					<aside class="notes">
						This embedded asciinema player is local.
					</aside>
					<iframe src='publish-demo.html'
						width="1920px" height="1080px"
					>
					</iframe>
				</section>

				<!--
				<section>
					<aside class="notes">
						This embedded asciinema player requires Internet connection.
					</aside>
					<script src="https://asciinema.org/a/ykcHljeTTw4cLKE5.js" id="asciicast-ykcHljeTTw4cLKE5" async="true"></script>
				</section>
				-->

				<!--
				<section>
					<aside class="notes">
						This embedded asciinema player is local but plays irksomely when red selections appear.
					</aside>
					<iframe src='about:blank'>
					<div
					class="asciinema"
					file="./assets/publish-demo.asciicast"
					style="width: 900px; height: 400px;"
					></div>
				</section>
				-->

				<section data-markdown>
					<textarea data-template>
						<aside class="notes">
							Importantly, in this way, two expensive steps must occur to accomplish the task of publishing a new file.

							First, the new file is copied into local scratch area.

							SKIPPABLE BEGIN

							This is dealt by overlayfs, it provides a nice illusion of editing the filesystem directly, and it enables the next step, the publish command, to instantly see what are the changed files to upload.

							SKIPPABLE END

							Second, the copy in the scratch area is transferred to the primary storage of CVMFS repo.

							It can be a local directory if we are working directly on the main server, called Stratum 0.

							It can be S3 location.

							And it can be a remote CVMFS server, running a so called Gateway service.
						</aside>

						<table width="100%">
							<tr width="100%">
								<td width="75%">
									<code style="white-space: nowrap;">cvmfs_server transaction</code>
								</td>
								<td width="25%">
									change overlayfs mode
								</td>
							</tr>
							<tr width="100%">
								<td width="75%">
									<code style="white-space: nowrap;">cp bigmodel.gguf /cvmfs/my.repo</code>
								</td>
								<td width="25%">
									copy to scratch area
								</td>
							</tr>
							<tr width="100%">
								<td width="60%">
									<code style="white-space: nowrap;">cvmfs_server publish</code>
								</td>
								<td width="25%">
									copy to primary storage
								</td>
							</tr>
						</table>

					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## cvmfs-rsync demo

						TODO asciicast
					</textarea>
				</section>


				<section data-markdown>
					<textarea data-template>
					## cvmfs-posix-tools: under the hood

					- uploads all the new files to S3 directly
					- pushes metadata changes to CVMFS Gateway host
					- waits for new CVMFS revision to become visible

					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
					## cvmfs-posix-tools: demo

					- live env on my laptop
					- fallback live env on my server, which I can ssh into if my laptop fails
					- asciinema
					- video recording
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
					## cvmfs-posix-tools: try it out now!

					- podman / docker container

					```
					[docker|podman] run -it docker://docker.io/andreyutkin/cvmfs-fosdem26-demos
					```

					- incus container, VM
					- qcow2 VM image

					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
					## Containers images on mounted CVMFS

					- demo

					</textarea>
				</section>

				<section>
					<aside class="notes">
						Here we use the lazy pulling.

						In this example we use a middle-sized image, slightly more than 1 Gigabyte.

						This image is developed and distributed by and for scientists, and is somewhat popular.

						It takes 25 seconds to fetch whatever is strictly necessary and execute the python process which
						loads the target module.

						Afterwards, the CVMFS cache is 600 Megabytes.
						So we skipped downloading quite a lot.
					</aside>
					<iframe src='demo-lazy-pulling-1.html'
						width="1920px" height="1080px"
					>
					</iframe>
				</section>

				<section>
					<aside class="notes">
						This embedded asciinema player is local.

						You can, of course, use the same container image the usual way: issue a normal podman run
						command and let it download the image.

						This demo was recorded on a very fast connection, by the way, the uplink is upward of a gigabit.

						(Wait for the animation to end with the "no space left on device")

						Unless it doesn't fit on your disk, in which case you'd have to go on a cleanup diversion, which
						happens regularly when you're working a lot with containers.

						This is hilarious but this was accidentally discovered during preparation of this presentation.
						There is no hidden tricks...
					</aside>
					<iframe src='demo-lazy-pulling-2.html'
						width="1920px" height="1080px"
					>
					</iframe>
				</section>

				<section data-markdown>
					<textarea data-template>
					## Questions, please!


					QR code to slides
					- contacts
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
					## References

					(Not for actual presentation)

					autkin demos: https://forge.autkin.net/autkin/cvmfs-fosdem26-demos
					</textarea>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="js/asciinema-player.min.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
			// https://github.com/mickaelbaron/revealasciinema/blob/master/workaround.html
			// https://discourse.asciinema.org/t/asciinema-reveal-js-display-issue/618/3
			/*
			{
				const asciinemas = document.getElementsByClassName("asciinema");
				for (let i = 0; i < asciinemas.length; i++) {
					const img = document.createElement("img");
					img.setAttribute("src", "assets/img/asciinema-player-icon.svg");
					asciinemas[i].appendChild(img);
				}
			}
			*/
			function checkForCasts(event) {
				const asciinema =
					event.currentSlide.getElementsByClassName("asciinema")[0];
				if (asciinema) {
					const filename = asciinema.getAttribute("file");
					if (asciinema && !asciinema.playerObject) {
						// Remove image
						const firstelementChild = asciinema.firstElementChild;
						if (firstelementChild) {
							asciinema.firstElementChild.remove();
						}

						asciinema.playerObject = AsciinemaPlayer.create(
							filename,
							asciinema,
							{ fit: "none" }
						);
					}
				}
			}
			Reveal.on("ready", checkForCasts);
			Reveal.on("slidechanged", checkForCasts);
		</script>
	</body>
</html>
