<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Multi-Petabyte Data Distribution in Industry & Science with CernVM File System</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white-fosdem-ish.css">
		<link rel="stylesheet" type="text/css" href="css/asciinema-player.css" />

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
					<textarea data-template>
					<img src="assets/img/fosdem-gear.svg">

					Multi-Petabyte Data Distribution in Industry & Science with CernVM File System

					<ul style="list-style-type: none;">
						<li>Georgios Christodoulis, CERN</li>
						<li>Andriy Utkin</li>
					</ul>

					<small>2026</small>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						# George's slides
					</textarea>
				</section>

				<!-- <section data-markdown  data-background-image="./assets/img/bottle.png"
					data-background-opacity="1">
					<textarea data-template>
						<aside class="notes">
							5 seconds pause to let viewers appreciate the picture.

							Move on.
						</aside>
					</textarea>
				</section>
				-->

				<!-- <section data-markdown  data-background-image="./assets/img/bottle.png"
					data-background-opacity="0.1"> -->
				<section data-markdown  >
					<textarea data-template>
					## cvmfs-posix-tools

					<aside class="notes">
						These are new tools, modelled after popular file utilities, which offer the convenience of direct effect on CVMFS repo.

					   	Can be seen as easier to use tools.

						They provide speedups in some modes.

						They can help avoid running out of disk space in scratch area.
					</aside>

					<!-- Deemphasize common prefix, emphasize second half of command names -->
					<ul style="columns: 2; list-style-type: none;">
						<li>cvmfs_<strong>chgrp</strong></li>
						<li>cvmfs_<strong>chmod</strong></li>
						<li>cvmfs_<strong>chown</strong></li>
						<li>cvmfs_<strong>insert</strong></li>
						<li>cvmfs_<strong>ln</strong></li>
						<li>cvmfs_<strong>mkdir</strong></li>
						<li>cvmfs_<strong>rm</strong></li>
						<li>cvmfs_<strong>rmdir</strong></li>
						<li>cvmfs_<strong>rsync</strong></li>
						<li>cvmfs_<strong>setfacl</strong></li>
						<li>cvmfs_<strong>touch</strong></li>
					</ul>

					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						## Changing contents,<br>the usual way

						* `cvmfs_server transaction`
						* make changes
						* `cvmfs_server publish`

						<aside class="notes">
							To explain why they are needed, let's briefly see how changing contents <strong>currently</strong> works from the user perspective.

							The first method you learn from the documentation to change the contents of your repo is this:

							* `cvmfs_server transaction`
							* make changes
							* `cvmfs_server publish`

						</aside>
					</textarea>
				</section>

				<section>
					<aside class="notes">
					</aside>

					How publishing looks

					<iframe src='publish-demo.html'
						width="1920px" height="1080px"
					>
					</iframe>
				</section>

				<!--
				<section>
					<aside class="notes">
						This embedded asciinema player requires Internet connection.
					</aside>
					<script src="https://asciinema.org/a/ykcHljeTTw4cLKE5.js" id="asciicast-ykcHljeTTw4cLKE5" async="true"></script>
				</section>
				-->

				<!--
				<section>
					<aside class="notes">
						This embedded asciinema player is local but plays irksomely when red selections appear.
					</aside>
					<iframe src='about:blank'>
					<div
					class="asciinema"
					file="./assets/publish-demo.asciicast"
					style="width: 900px; height: 400px;"
					></div>
				</section>
				-->

				<section data-markdown>
					<textarea data-template>
						<aside class="notes">
							Importantly, in this way, two expensive steps must occur to accomplish the task of publishing a new file.

							First, the new file is copied into local scratch area.

							SKIPPABLE BEGIN

							This is dealt by overlayfs, it provides a nice illusion of editing the filesystem directly, and it enables the next step, the publish command, to instantly see what are the changed files to upload.

							SKIPPABLE END

							Second, the copy in the scratch area is transferred to the primary storage of CVMFS repo.

							It can be a local directory if we are working directly on the main server, called Stratum 0.

							It can be S3 location.

							And it can be a remote CVMFS server, running a so called Gateway service.
						</aside>

						<table width="100%">
							<tr width="100%">
								<td width="75%">
									<code style="white-space: nowrap;">cvmfs_server transaction</code>
								</td>
								<td width="25%">
									change overlayfs mode
								</td>
							</tr>
							<tr width="100%">
								<td width="75%">
									<code style="white-space: nowrap;">cp bigmodel.gguf /cvmfs/my.repo</code>
								</td>
								<td width="25%">
									copy to scratch area
								</td>
							</tr>
							<tr width="100%">
								<td width="60%">
									<code style="white-space: nowrap;">cvmfs_server publish</code>
								</td>
								<td width="25%">
									copy to primary storage
								</td>
							</tr>
						</table>

					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## cvmfs-rsync demo
					</textarea>
				</section>

				<section>
					<aside class="notes">
						This is publish method adding a 4 Gigabyte file into an S3-backed CVMFS repository.

						In this demo compression is disabled.
						Compression is on by default.
					</aside>

					publish command in action

					<iframe src='demo-publish-bigmodel.html'
						width="1920px" height="1080px"
					>
					</iframe>
				</section>

				<section>
					<aside class="notes">
						This is cvmfs_rsync adding the same 4 Gigabyte file.
						But it ends up finishing a lot faster, and a big factor to that is the layout of data CVMFS
						stores on S3.

						Here, cvmfs_rsync was configured via yaml file to not chunk it, but to upload it to S3 with a
						location pattern reflecting its directory path, and this ends up being a lot faster.

						The layout used by publish command is called Content Addressable Storage. A well-recognized
						example of this concept is object storage in Git repositories. It enables deduplication and
						simple integrity checks(?).

						cvmfs_rsync can be told to upload the files in the same way as publish command.

					</aside>

					cvmfs_rsync in action

					<iframe src='demo-cvmfs_rsync-external-faster-plus-s3-listing.html'
						width="1920px" height="1080px"
					>
					</iframe>
				</section>


				<section data-markdown>
					<textarea data-template>
					## cvmfs-posix-tools: under the hood

					- uploads all the new files to S3 directly
					- pushes metadata changes to CVMFS Gateway host
					- waits for new CVMFS revision to become visible

					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
					## Containers images on mounted CVMFS

					demo

					</textarea>
				</section>

				<section>
					<aside class="notes">
						Here we use the lazy pulling.

						Here we use a popular image slightly bigger than 1 Gigabyte.

						This image is developed and distributed by and for scientists, and is somewhat popular.

						It takes 25 seconds to fetch whatever is strictly necessary and execute the python process which
						loads the target module.

						Afterwards, the CVMFS cache is 600 Megabytes.
						So we skipped downloading quite a lot.
					</aside>

					Lazy pulling in action

					<iframe src='demo-lazy-pulling-1.html'
						width="1920px" height="1080px"
					>
					</iframe>
				</section>

				<section>
					<aside class="notes">
						You can, of course, use the same container image the usual way: issue a normal podman run
						command and let it download the image.

						This demo was recorded on a very fast connection, by the way, the uplink is upward of a gigabit.

						(Wait for the animation to end with the "no space left on device")

						Unless it doesn't fit on your disk, in which case you'd have to go on a cleanup diversion or
						resize your machine.
					</aside>

					Normal image pulling

					<iframe src='demo-lazy-pulling-2.html'
						width="1920px" height="1080px"
					>
					</iframe>
				</section>

				<section data-markdown>
					<textarea data-template>
					## CVMFS install party + adoption Q&A

					BOF

					Sunday 10:00

					UA.4.222

					QR code

					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
					## Questions, please!

					QR code to slides
					- contacts
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
					## References

					(Not for actual presentation)

					autkin demos: https://forge.autkin.net/autkin/cvmfs-fosdem26-demos
					</textarea>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="js/asciinema-player.min.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				slideNumber: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
			// https://github.com/mickaelbaron/revealasciinema/blob/master/workaround.html
			// https://discourse.asciinema.org/t/asciinema-reveal-js-display-issue/618/3
			/*
			{
				const asciinemas = document.getElementsByClassName("asciinema");
				for (let i = 0; i < asciinemas.length; i++) {
					const img = document.createElement("img");
					img.setAttribute("src", "assets/img/asciinema-player-icon.svg");
					asciinemas[i].appendChild(img);
				}
			}
			*/
			function checkForCasts(event) {
				const asciinema =
					event.currentSlide.getElementsByClassName("asciinema")[0];
				if (asciinema) {
					const filename = asciinema.getAttribute("file");
					if (asciinema && !asciinema.playerObject) {
						// Remove image
						const firstelementChild = asciinema.firstElementChild;
						if (firstelementChild) {
							asciinema.firstElementChild.remove();
						}

						asciinema.playerObject = AsciinemaPlayer.create(
							filename,
							asciinema,
							{ fit: "none" }
						);
					}
				}
			}
			Reveal.on("ready", checkForCasts);
			Reveal.on("slidechanged", checkForCasts);
		</script>
	</body>
</html>
